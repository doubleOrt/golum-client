
1- When infinite scrolling all the way to the bottom, multiple calls are made to the PHP page, so after you close the modal, and re-open the comments by clicking the button that triggers the comments, The line that empties the content of the comment container modal is executed. However, this request does not pass the commentsPreventMultipleCalls check in the get_comments function. Therefore, you end up with an empty container for the comments, and not a call to fill that empty container with comments, and now the last of the multiple calls made during the scroll to the bottom is on its way back from the PHP page, carrying an empty array because you had arrived at the bottom and there were no more comments to retrieve. So now, in the callback function, the conditional that is supposed to add .emptyNowPlaceholder's evaluates to true, and therefore you end up with that .emptyNowPlaceholder instead of the comments you wished to saw when you clicked the see comments button, and you are confused as hell because just 2 seconds ago you saw like 20 comments. We have fixed this by setting the commentsPreventMultipleCalls to true before we make the request and after you click the see comments button, and aborting the last of the multiple requests made during the scroll to the bottom-most comments, this second step is optional, however if you don't do it, you will end up with a useless out-of-place .emptyNowPlaceholder lying beneath the comments you are to get from the call you made by clicking the see comments button.

2- without this callback, due to the architecture of our application and our implementation of user profiles, 
whenever you were on the user-profile main screen and you opened some modals from there and then one of these 
modals ended up being a user-profile modal, when you closed all the modals, the base user-profile would be a
desolate and empty element, with no content. The following lines are supposed to address this bug.

3- This bug is detailed in a Github issue i raised to dogfalo/Materializecss (in that issue i explain 2 bugs, the latter is this supposed to be this bug).

4- this snippet extensively deals with an issue where if you hold an element and then release it, 
it won't count as a click, but we want it to count as a click, since all the apps on my S7 count a hold-release as a click.

5- In out PHP code, we run htmlspecialchars() on all our output, which will replace single quotes with an HTML entity that contains "#" character, so if we immediately called the handleTags() function on that raw value, the function would replace everything that comes after the "#" in that entity with the markup for a tag (it shouldn't do that, obviously), which will result in that entity not being loaded correctly when it is added to the page. To work around this, we add the raw values to the page first (the ones where hashtags are still just raw text), and then we run the handleTags() function on the value that has been already rendered (meaning that the "#" character is no longer there, so we won't run into the bug).

6- the lines concerning chat_prevent_multiple_calls here have been added because of the line that 
empties the $(".chatWindowChild"), because that emptying would trigger a scroll event which we are 
capturing, so an Ajax request will be made (it should not be made since the user did not actually 
scroll) that will mess all our logic (mainly the subscribing and unsubscribing part, since this 
request will mess up our last_opened_chat_id variable).

7- The user uploads a file, now the value of the file-input is set and the uploaded file is previewed. Then they open up the upload dialog again, however, this time they press the cancel button, so the value of the file-input is set to null, normally, you would also empty the previewed image so that the user knows there is nothing to upload. However, i don't want this functionality, that is, i don't want to lose the previous upload if a user opens up the upload dialog and then cancels it, i want to retain the previous upload. Normally, you would expect me to do this by saving the value of the file-input, and then re-applying that value to the file-input if the upload was cancelled, but due to security reasons, you cannot set the value of file-inputs, their value can only be set by the upload dialog. To work around this, i don't save the value of the file-input everytime the upload dialog is opened, i clone the file-input, change its id to "x_temp", and then when the upload dialog is closed, i check whether the user actually uploaded a file or just canceled the upload dialog, if the former is true, then i remove the "x_temp" input i previously cloned, if the latter is true, and that is the part which deals with the issue, i get the ID of the actual file-input, remove that actual file-input which now has a null value, and change the ID of the clone, which still holds the old value, the value that points to the previewed image, to the ID of the actual file-input i deleted. 