
First, to ease up your job and remove the complexity of thinking in 2 dimensions (a browser, within an app), here is something i have noted (may not be entirely true, but so far, everything is working that way for me): With Cordova apps, the equivalent of changing Chrome tabs for example, is opening the app when it was in the background, and the equivalent of a refresh is when your app was closed and the user opened it back again without closing the browser.


1- When infinite scrolling all the way to the bottom, multiple calls are made to the PHP page, so after you close the modal, and re-open the comments by clicking the button that triggers the comments, The line that empties the content of the comment container modal is executed. However, this request does not pass the commentsPreventMultipleCalls check in the get_comments function. Therefore, you end up with an empty container for the comments, and not a call to fill that empty container with comments, and now the last of the multiple calls made during the scroll to the bottom is on its way back from the PHP page, carrying an empty array because you had arrived at the bottom and there were no more comments to retrieve. So now, in the callback function, the conditional that is supposed to add .emptyNowPlaceholder's evaluates to true, and therefore you end up with that .emptyNowPlaceholder instead of the comments you wished to saw when you clicked the see comments button, and you are confused as hell because just 2 seconds ago you saw like 20 comments. We have fixed this by setting the commentsPreventMultipleCalls to true before we make the request and after you click the see comments button, and aborting the last of the multiple requests made during the scroll to the bottom-most comments, this second step is optional, however if you don't do it, you will end up with a useless out-of-place .emptyNowPlaceholder lying beneath the comments you are to get from the call you made by clicking the see comments button.

2- without this callback, due to the architecture of our application and our implementation of user profiles, 
whenever you were on the user-profile main screen and you opened some modals from there and then one of these 
modals ended up being a user-profile modal, when you closed all the modals, the base user-profile would be a
desolate and empty element, with no content. The following lines are supposed to address this bug.

3- This bug is detailed in a Github issue i raised to dogfalo/Materializecss (in that issue i explain 2 bugs, the latter is this supposed to be this bug).

4- this snippet extensively deals with an issue where if you hold an element and then release it, 
it won't count as a click, but we want it to count as a click, since all the apps on my S7 count a hold-release as a click.

5- In out PHP code, we run htmlspecialchars() on all our output, which will replace single quotes with an HTML entity that contains "#" character, so if we immediately called the handleTags() function on that raw value, the function would replace everything that comes after the "#" in that entity with the markup for a tag (it shouldn't do that, obviously), which will result in that entity not being loaded correctly when it is added to the page. To work around this, we add the raw values to the page first (the ones where hashtags are still just raw text), and then we run the handleTags() function on the value that has been already rendered (meaning that the "#" character is no longer there, so we won't run into the bug).

6- the lines concerning chat_prevent_multiple_calls here have been added because of the line that 
empties the $(".chatWindowChild"), because that emptying would trigger a scroll event which we are 
capturing, so an Ajax request will be made (it should not be made since the user did not actually 
scroll) that will mess all our logic (mainly the subscribing and unsubscribing part, since this 
request will mess up our last_opened_chat_id variable).

7- The user uploads a file, now the value of the file-input is set and the uploaded file is previewed. Then they open up the upload dialog again, however, this time they press the cancel button, so the value of the file-input is set to null, normally, you would also empty the previewed image so that the user knows there is nothing to upload. However, i don't want this functionality, that is, i don't want to lose the previous upload if a user opens up the upload dialog and then cancels it, i want to retain the previous upload. Normally, you would expect me to do this by saving the value of the file-input, and then re-applying that value to the file-input if the upload was cancelled, but due to security reasons, you cannot set the value of file-inputs, their value can only be set by the upload dialog. To work around this, i don't save the value of the file-input everytime the upload dialog is opened, i clone the file-input, change its id to "x_temp", and then when the upload dialog is closed, i check whether the user actually uploaded a file or just canceled the upload dialog, if the former is true, then i remove the "x_temp" input i previously cloned, if the latter is true, and that is the part which deals with the issue, i get the ID of the actual file-input, remove that actual file-input which now has a null value, and change the ID of the clone, which still holds the old value, the value that points to the previewed image, to the ID of the actual file-input i deleted. 

8- This determines whether or not to open a new modal even if it is currently being viewed. Pass "true" in cases for exmaple when you are looking at a comment's replies, and then someone replies to one of your other comments and you receive a push notification, if you click on that notification, it will not just load the replies for the comment in the push into the currently opened modal as it would if you passed "false", instead, it opens a new replies modal on top of the current one. And pass "false" in cases for example when you are in the #tagPostsModal and you click on the tag for which the current #tagPostsModal has been opened, if you pass "true", a new modal will be opened for the same tag that the current #tagPostsModal is opened for, which is just inconsistent. And here is how we determine whether or not to pass "true" or "false" when a push notification that requires a modal to be opened is tapped (here we assume that the tapped notification is a "new comment" notification):

	- modal is already being viewed but for the comments of a different post > true
	- modal is already being viewed and for the comments of the post which the notification wants us to open > false
	- modal is not already being viewed (in this case, it doesn't matter whether we pass "true" or "false", since if a modal is not being already viewed, a new one will be opened regardless of anything) > false

9- The relation between our chat architecture and new message push-notifications:

	- The chat that the push-notification message belongs to is currently opened: We do nothing, since it will have already been dealt with by our websockets connection.
	- The chat that the push-notification message belongs to is currently not opened, but another chat is opened: We replace that chat with the chat that the push-notification message belongs to.
	- The "#chatModal" is not currently on top, or it is not opened: We open the "#chatModal" and then load the chat that the push-notification message belongs to.    

	
	The first two cases will evaluate to true only when the app is opened, the "#chatModal" is opened and it's on top. While the latter case is going to evaluate to true whenever the "#chatModal" is not opened already or it is but it is not on top. The third case is the default for when the user clicks a push-notification while the app is closed, however, it can evaluate to true even in cases where the app is already opened (e.g when the "#chatModal" is not on top). The first and second cases on the other hand, will evaluate to true in all cases where the "#chatModal" is already opened and on top (the first case if the "#chatModal" is opened with the chat of the push-notification message, the second case if the "#chatModal" is opened for a chat different than the one in the push-notification message). 
	
	And do note that no conditionals or traces of the first case exist in the "new_message_push_notification_received()" function, it is imaginary, i made it to help you visualize everything in a more clear way.
	
	I hope that the above summed it up, or at least eased it up.
	